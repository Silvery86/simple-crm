// This is your Prisma schema file for Simple CRM
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// E-commerce platform types
enum StorePlatform {
  WOO       // WooCommerce
  SHOPIFY   // Shopify (future support)
}

// Shipment tracking status from providers (AfterShip, 17Track)
enum ShipmentStatus {
  UNKNOWN
  INFO_RECEIVED     // Tracking info created but no movement yet
  IN_TRANSIT        // Package is on the way
  OUT_FOR_DELIVERY  // Package is out for delivery
  DELIVERED         // Package delivered successfully
  EXCEPTION         // Delivery exception or delay
  FAILED_ATTEMPT    // Failed delivery attempt
  RETURNED          // Package returned to sender
}

// Email campaign lifecycle status
enum CampaignStatus {
  DRAFT      // Campaign being created
  SCHEDULED  // Campaign scheduled for future
  RUNNING    // Campaign currently sending
  DONE       // Campaign completed
  CANCELLED  // Campaign cancelled
}

// Email event types from Mailjet webhooks
enum EmailEventType {
  DELIVERED    // Email delivered to recipient
  OPEN         // Email opened by recipient
  CLICK        // Link clicked in email
  BOUNCE       // Email bounced (hard/soft)
  COMPLAINT    // Spam complaint
  UNSUBSCRIBE  // Recipient unsubscribed
}

// AI content generation job types
enum AIJobType {
  IMAGE  // AI-generated product images
  VIDEO  // AI-generated product videos
}

// AI job processing status
enum AIJobStatus {
  QUEUED     // Job waiting in queue
  RUNNING    // Job currently processing
  SUCCEEDED  // Job completed successfully
  FAILED     // Job failed with error
}

// User roles for RBAC (Role-Based Access Control)
enum RoleName {
  ADMIN     // Full system access
  MANAGER   // Limited admin access
  PARTNER   // Store-specific access only
}

// ============================================================================
// USER MANAGEMENT & AUTHENTICATION
// ============================================================================

// Users table - integrates with Firebase Auth
model User {
  id          String    @id @default(cuid())
  email       String    @unique
  name        String?
  firebaseUid String    @unique // Firebase UID for authentication
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Many-to-many relationship with roles
  userRoles UserRole[]

  @@map("users")
}

// Roles for RBAC system
model Role {
  id          String  @id @default(cuid())
  name        String  @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Many-to-many relationship with users
  userRoles UserRole[]

  @@map("roles")
}

// Junction table for user-role many-to-many relationship
model UserRole {
  id     String @id @default(cuid())
  userId String
  roleId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@map("user_roles")
}

// ============================================================================
// MULTI-STORE MANAGEMENT
// ============================================================================

// E-commerce stores (WooCommerce, Shopify)
model Store {
  id        String        @id @default(cuid())
  name      String
  platform  StorePlatform
  domain    String
  // OAuth tokens/API keys (should be encrypted before storing)
  settings  Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  products  StoreProductMap[]
  orders    Order[]
  customers StoreCustomerMap[]
  credentials IntegrationCredential[]

  @@map("stores")
}

// ============================================================================
// PRODUCT CATALOG MANAGEMENT
// ============================================================================

// Normalized brand data across all stores
model Brand {
  id        String   @id @default(cuid())
  name      String   @unique
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  products  Product[]
  orders    Order[]
  campaigns Campaign[]

  @@map("brands")
}

// Normalized product data + raw payload from source platforms
model Product {
  id         String           @id @default(cuid())
  title      String
  description String?
  brandId    String?
  
  // Raw data from source platform (WooCommerce/Shopify)
  rawPayload Json             // JSONB for flexible data storage

  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  // Relationships
  brand      Brand?           @relation(fields: [brandId], references: [id])
  variants   ProductVariant[]
  maps       StoreProductMap[]
  orderItems OrderItem[]

  @@map("products")
}

// Product variants (SKU, price variations)
model ProductVariant {
  id          String   @id @default(cuid())
  productId   String
  sku         String?
  price       Decimal?
  currency    String?
  rawPayload  Json?    // Variant-specific data from source

  // Relationships
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  orderItems OrderItem[]

  @@index([sku])
  @@map("product_variants")
}

// Maps products to stores (handles multi-store products)
model StoreProductMap {
  id         String  @id @default(cuid())
  storeId    String
  productId  String
  externalId String  // Product ID in source store (WooCommerce/Shopify)

  // Relationships
  store   Store   @relation(fields: [storeId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([storeId, externalId])
  @@map("store_product_maps")
}

// ============================================================================
// CUSTOMER MANAGEMENT
// ============================================================================

// Normalized customer data supporting multiple emails/phones
model Customer {
  id         String   @id @default(cuid())
  name       String?
  emails     String[] // Array of email addresses
  phones     String[] // Array of phone numbers
  acceptsMk  Boolean  @default(false) // Marketing acceptance
  tags       String[] // Customer segmentation tags
  rawPayload Json?    // Additional data from source platforms

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relationships
  orders     Order[]
  maps       StoreCustomerMap[]

  @@map("customers")
}

// Maps customers to stores (handles multi-store customers)
model StoreCustomerMap {
  id         String @id @default(cuid())
  storeId    String
  customerId String
  externalId String   // Customer ID in source store

  // Relationships
  store    Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([storeId, externalId])
  @@map("store_customer_maps")
}

// ============================================================================
// ORDER MANAGEMENT & TRACKING
// ============================================================================

// Orders from e-commerce platforms
model Order {
  id         String   @id @default(cuid())
  storeId    String
  customerId String?
  status     String   // Order status from source platform
  total      Decimal  // Order total amount
  currency   String   // Currency code (USD, VND, etc.)

  brandId    String?  // Associated brand (optional)
  externalId String   // Order ID from source platform
  rawPayload Json     // Complete order data from source

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relationships
  store     Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)
  customer  Customer? @relation(fields: [customerId], references: [id])
  brand     Brand?    @relation(fields: [brandId], references: [id])
  items     OrderItem[]
  shipment  Shipment?
  events    OrderEvent[]

  @@unique([storeId, externalId])
  @@index([status])
  @@index([createdAt])
  @@map("orders")
}

// Individual items within an order
model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  productId String?
  variantId String?
  quantity  Int
  price     Decimal?
  currency  String?
  rawPayload Json?   // Item-specific data from source

  // Relationships
  order   Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product?       @relation(fields: [productId], references: [id])
  variant ProductVariant? @relation(fields: [variantId], references: [id])

  @@map("order_items")
}

// Order lifecycle events for audit trail
model OrderEvent {
  id        String   @id @default(cuid())
  orderId   String
  type      String   // Event type (status_change, payment, etc.)
  payload   Json?    // Event-specific data
  createdAt DateTime @default(now())

  // Relationships
  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, type])
  @@index([createdAt])
  @@map("order_events")
}

// ============================================================================
// SHIPMENT & LOGISTICS TRACKING
// ============================================================================

// Shipment tracking information from providers (AfterShip, 17Track)
model Shipment {
  id             String         @id @default(cuid())
  orderId        String         @unique
  carrier        String         // Shipping carrier code
  trackingNumber String         // Tracking number from carrier
  status         ShipmentStatus @default(UNKNOWN)
  lastCheckedAt  DateTime?      // Last time tracking was updated

  // Relationships
  order   Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  events  TrackingEvent[]

  @@index([trackingNumber])
  @@index([status])
  @@map("shipments")
}

// Individual tracking events in shipment journey
model TrackingEvent {
  id          String         @id @default(cuid())
  shipmentId  String
  status      ShipmentStatus
  description String?        // Event description from provider
  location    String?        // Location where event occurred
  occurredAt  DateTime       // When the event happened
  rawPayload  Json?          // Complete data from tracking provider

  // Relationships
  shipment Shipment @relation(fields: [shipmentId], references: [id], onDelete: Cascade)

  @@index([shipmentId, occurredAt])
  @@map("tracking_events")
}

// ============================================================================
// EMAIL MARKETING & CAMPAIGNS
// ============================================================================

// Email templates for marketing campaigns
model EmailTemplate {
  id        String   @id @default(cuid())
  name      String   @unique
  subject   String
  bodyMjml  String?  // MJML template source
  bodyHtml  String?  // Compiled HTML version
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  campaigns Campaign[]

  @@map("email_templates")
}

// Marketing campaigns targeting customer segments
model Campaign {
  id          String         @id @default(cuid())
  name        String
  brandId     String?        // Brand-specific campaigns
  segmentSql  String         // SQL query for customer segmentation
  templateId  String
  status      CampaignStatus @default(DRAFT)
  scheduledAt DateTime?      // When to send the campaign
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relationships
  brand     Brand?        @relation(fields: [brandId], references: [id])
  template  EmailTemplate @relation(fields: [templateId], references: [id])
  sends     EmailSend[]

  @@map("campaigns")
}

// Individual email sends within a campaign
model EmailSend {
  id          String   @id @default(cuid())
  campaignId  String
  toEmail     String
  subject     String
  bodyHtml    String
  status      String    // queued/sent/failed
  providerId  String?   // ID from email provider (Mailjet)
  createdAt   DateTime  @default(now())

  // Relationships
  campaign Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  events   EmailEvent[]

  @@index([campaignId, status])
  @@map("email_sends")
}

// Email engagement events from provider webhooks
model EmailEvent {
  id         String        @id @default(cuid())
  emailSendId String
  type       EmailEventType
  meta       Json?         // Event metadata from provider
  createdAt  DateTime @default(now())

  // Relationships
  emailSend EmailSend @relation(fields: [emailSendId], references: [id], onDelete: Cascade)

  @@index([emailSendId, type])
  @@index([type, createdAt])
  @@map("email_events")
}

// ============================================================================
// AI CONTENT GENERATION
// ============================================================================

// AI-powered content generation jobs (images, videos)
model AIJob {
  id          String      @id @default(cuid())
  type        AIJobType   // IMAGE or VIDEO generation
  promptIn    String      // Input prompt for AI
  promptOut   String?     // Generated/refined prompt
  status      AIJobStatus @default(QUEUED)
  outputUrl   String?     // URL to generated content
  driveFileId String?     // Google Drive file ID
  meta        Json?       // Additional metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status])
  @@index([type, status])
  @@map("ai_jobs")
}

// ============================================================================
// INTEGRATION CREDENTIALS & SECRETS
// ============================================================================

// Encrypted storage for third-party integration credentials
model IntegrationCredential {
  id        String   @id @default(cuid())
  storeId   String?  // Store-specific credentials (optional)
  provider  String   // Provider name: "mailjet", "aftership", "17track", "gemini", "drive"
  data      Json     // Encrypted JSON containing API keys, tokens, etc.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  store Store? @relation(fields: [storeId], references: [id], onDelete: SetNull)

  @@index([storeId, provider])
  @@unique([storeId, provider]) // Prevent duplicate credentials per store-provider
  @@map("integration_credentials")
}
